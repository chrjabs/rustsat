// !!! Auto-generated by codegen, do not edit manually !!!

use std::ffi::{c_int, c_void};

use rustsat::{
    encodings::pb::{
        BinaryAdder, BoundLower, BoundLowerIncremental, BoundUpper, BoundUpperIncremental,
        DynamicPolyWatchdog, EncodeIncremental, GeneralizedTotalizer,
    },
    types::Lit,
};

use super::{CAssumpCollector, CClauseCollector, ClauseCollector, MaybeError, VarManager};

/// Creates a new [`GeneralizedTotalizer`] pseudo-Boolean encoding
#[no_mangle]
#[allow(clippy::missing_safety_doc)]
pub unsafe extern "C" fn gte_new() -> *mut GeneralizedTotalizer {
    Box::into_raw(Box::default())
}

/// Frees the memory associated with a [`GeneralizedTotalizer`]
///
/// # Safety
///
/// `gte` must be a return value of [`gte_new`] and cannot be used afterwards again.
#[no_mangle]
pub unsafe extern "C" fn gte_drop(gte: *mut GeneralizedTotalizer) {
    drop(Box::from_raw(gte));
}

/// Reserves all auxiliary variables that the encoding might need
///
/// All calls to [`gte_encode_ub`] following a call to this function are guaranteed to not increase
/// the value of `n_vars_used`. This does _not_ hold if [`gte_add`] is called in between
///
/// # Safety
///
/// `gte` must be a return value of [`gte_new`] that [`gte_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn gte_reserve(gte: *mut GeneralizedTotalizer, n_vars_used: &mut u32) {
    let mut var_manager = VarManager::new(n_vars_used);
    (*gte).reserve(&mut var_manager);
}

/// Adds a new input literal to a [`GeneralizedTotalizer`] encoding
///
/// # Errors
///
/// - If `lit` is not a valid IPASIR-style literal (e.g., `lit = 0`),
///   [`MaybeError::InvalidLiteral`] is returned
///
/// # Safety
///
/// `gte` must be a return value of [`gte_new`] that [`gte_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn gte_add(
    gte: *mut GeneralizedTotalizer,
    lit: c_int,
    weight: usize,
) -> MaybeError {
    let Ok(lit) = Lit::from_ipasir(lit) else {
        return MaybeError::InvalidLiteral;
    };
    (*gte).extend([(lit, weight)]);
    MaybeError::Ok
}

/// Lazily builds the _change in_ pseudo-Boolean encoding to enable upper bounds in a given range.
/// A change might be added literals or changed bounds.
///
/// The min and max bounds are inclusive. After a call to [`gte_encode_ub`] with `min_bound=2` and
/// `max_bound=4` bound including `<= 2` and `<= 4` can be enforced.
///
/// Clauses are returned via the `collector`. The `collector` function should expect clauses to be
/// passed similarly to `ipasir_add`, as a 0-terminated sequence of literals where the literals are
/// passed as the first argument and the `collector_data` as a second.
///
/// `n_vars_used` must be the number of variables already used and will be incremented by the
/// number of variables used up in the encoding.
///
/// # Panics
///
/// If `min_bound > max_bound`.
///
/// # Safety
///
/// `gte` must be a return value of [`gte_new`] that [`gte_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn gte_encode_ub(
    gte: *mut GeneralizedTotalizer,
    min_bound: usize,
    max_bound: usize,
    n_vars_used: &mut u32,
    collector: CClauseCollector,
    collector_data: *mut c_void,
) {
    assert!(min_bound <= max_bound);
    let mut collector = ClauseCollector::new(collector, collector_data);
    let mut var_manager = VarManager::new(n_vars_used);
    (*gte)
        .encode_ub_change(min_bound..=max_bound, &mut collector, &mut var_manager)
        .expect("CClauseCollector cannot report out of memory");
}

/// Returns assumptions/units for enforcing an upper bound (`sum of lits <= ub`). Make sure that
/// [`gte_encode_ub`] has been called adequately and nothing has been called afterwards, otherwise
/// [`MaybeError::NotEncoded`] will be returned.
///
/// Assumptions are returned via the collector callback. There is _no_ terminating zero, all
/// assumptions are passed when [`gte_enforce_ub`] returns.
///
/// # Safety
///
/// `gte` must be a return value of [`gte_new`] that [`gte_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn gte_enforce_ub(
    gte: *mut GeneralizedTotalizer,
    ub: usize,
    collector: CAssumpCollector,
    collector_data: *mut c_void,
) -> MaybeError {
    match (*gte).enforce_ub(ub) {
        Ok(assumps) => {
            assumps
                .into_iter()
                .for_each(|a| collector(a.to_ipasir(), collector_data));
            MaybeError::Ok
        }
        Err(err) => err.into(),
    }
}

/// Creates a new [`BinaryAdder`] pseudo-Boolean encoding
#[no_mangle]
#[allow(clippy::missing_safety_doc)]
pub unsafe extern "C" fn bin_adder_new() -> *mut BinaryAdder {
    Box::into_raw(Box::default())
}

/// Frees the memory associated with a [`BinaryAdder`]
///
/// # Safety
///
/// `bin_adder` must be a return value of [`bin_adder_new`] and cannot be used afterwards again.
#[no_mangle]
pub unsafe extern "C" fn bin_adder_drop(bin_adder: *mut BinaryAdder) {
    drop(Box::from_raw(bin_adder));
}

/// Reserves all auxiliary variables that the encoding might need
///
/// All calls to [`bin_adder_encode_ub`] following a call to this function are guaranteed to not increase
/// the value of `n_vars_used`. This does _not_ hold if [`bin_adder_add`] is called in between
///
/// # Safety
///
/// `bin_adder` must be a return value of [`bin_adder_new`] that [`bin_adder_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn bin_adder_reserve(bin_adder: *mut BinaryAdder, n_vars_used: &mut u32) {
    let mut var_manager = VarManager::new(n_vars_used);
    (*bin_adder).reserve(&mut var_manager);
}

/// Adds a new input literal to a [`BinaryAdder`] encoding
///
/// # Errors
///
/// - If `lit` is not a valid IPASIR-style literal (e.g., `lit = 0`),
///   [`MaybeError::InvalidLiteral`] is returned
///
/// # Safety
///
/// `bin_adder` must be a return value of [`bin_adder_new`] that [`bin_adder_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn bin_adder_add(
    bin_adder: *mut BinaryAdder,
    lit: c_int,
    weight: usize,
) -> MaybeError {
    let Ok(lit) = Lit::from_ipasir(lit) else {
        return MaybeError::InvalidLiteral;
    };
    (*bin_adder).extend([(lit, weight)]);
    MaybeError::Ok
}

/// Lazily builds the _change in_ pseudo-Boolean encoding to enable upper bounds in a given range.
/// A change might be added literals or changed bounds.
///
/// The min and max bounds are inclusive. After a call to [`bin_adder_encode_ub`] with `min_bound=2` and
/// `max_bound=4` bound including `<= 2` and `<= 4` can be enforced.
///
/// Clauses are returned via the `collector`. The `collector` function should expect clauses to be
/// passed similarly to `ipasir_add`, as a 0-terminated sequence of literals where the literals are
/// passed as the first argument and the `collector_data` as a second.
///
/// `n_vars_used` must be the number of variables already used and will be incremented by the
/// number of variables used up in the encoding.
///
/// # Panics
///
/// If `min_bound > max_bound`.
///
/// # Safety
///
/// `bin_adder` must be a return value of [`bin_adder_new`] that [`bin_adder_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn bin_adder_encode_ub(
    bin_adder: *mut BinaryAdder,
    min_bound: usize,
    max_bound: usize,
    n_vars_used: &mut u32,
    collector: CClauseCollector,
    collector_data: *mut c_void,
) {
    assert!(min_bound <= max_bound);
    let mut collector = ClauseCollector::new(collector, collector_data);
    let mut var_manager = VarManager::new(n_vars_used);
    (*bin_adder)
        .encode_ub_change(min_bound..=max_bound, &mut collector, &mut var_manager)
        .expect("CClauseCollector cannot report out of memory");
}

/// Returns assumptions/units for enforcing an upper bound (`sum of lits <= ub`). Make sure that
/// [`bin_adder_encode_ub`] has been called adequately and nothing has been called afterwards, otherwise
/// [`MaybeError::NotEncoded`] will be returned.
///
/// Assumptions are returned via the collector callback. There is _no_ terminating zero, all
/// assumptions are passed when [`bin_adder_enforce_ub`] returns.
///
/// # Safety
///
/// `bin_adder` must be a return value of [`bin_adder_new`] that [`bin_adder_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn bin_adder_enforce_ub(
    bin_adder: *mut BinaryAdder,
    ub: usize,
    collector: CAssumpCollector,
    collector_data: *mut c_void,
) -> MaybeError {
    match (*bin_adder).enforce_ub(ub) {
        Ok(assumps) => {
            assumps
                .into_iter()
                .for_each(|a| collector(a.to_ipasir(), collector_data));
            MaybeError::Ok
        }
        Err(err) => err.into(),
    }
}

/// Lazily builds the _change in_ pseudo-Boolean encoding to enable lower bounds in a given range.
/// A change might be added literals or changed bounds.
///
/// The min and max bounds are inclusive. After a call to [`bin_adder_encode_lb`] with `min_bound=2` and
/// `max_bound=4` bound including `<= 2` and `<= 4` can be enforced.
///
/// Clauses are returned via the `collector`. The `collector` function should expect clauses to be
/// passed similarly to `ipasir_add`, as a 0-terminated sequence of literals where the literals are
/// passed as the first argument and the `collector_data` as a second.
///
/// `n_vars_used` must be the number of variables already used and will be incremented by the
/// number of variables used up in the encoding.
///
/// # Panics
///
/// If `min_bound > max_bound`.
///
/// # Safety
///
/// `bin_adder` must be a return value of [`bin_adder_new`] that [`bin_adder_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn bin_adder_encode_lb(
    bin_adder: *mut BinaryAdder,
    min_bound: usize,
    max_bound: usize,
    n_vars_used: &mut u32,
    collector: CClauseCollector,
    collector_data: *mut c_void,
) {
    assert!(min_bound <= max_bound);
    let mut collector = ClauseCollector::new(collector, collector_data);
    let mut var_manager = VarManager::new(n_vars_used);
    (*bin_adder)
        .encode_lb_change(min_bound..=max_bound, &mut collector, &mut var_manager)
        .expect("CClauseCollector cannot report out of memory");
}

/// Returns assumptions/units for enforcing a lower bound (`sum of lits <= ub`). Make sure that
/// [`bin_adder_encode_lb`] has been called adequately and nothing has been called afterwards, otherwise
/// [`MaybeError::NotEncoded`] will be returned.
///
/// Assumptions are returned via the collector callback. There is _no_ terminating zero, all
/// assumptions are passed when [`bin_adder_enforce_ub`] returns.
///
/// # Safety
///
/// `bin_adder` must be a return value of [`bin_adder_new`] that [`bin_adder_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn bin_adder_enforce_lb(
    bin_adder: *mut BinaryAdder,
    lb: usize,
    collector: CAssumpCollector,
    collector_data: *mut c_void,
) -> MaybeError {
    match (*bin_adder).enforce_lb(lb) {
        Ok(assumps) => {
            assumps
                .into_iter()
                .for_each(|a| collector(a.to_ipasir(), collector_data));
            MaybeError::Ok
        }
        Err(err) => err.into(),
    }
}

/// Creates a new [`DynamicPolyWatchdog`] pseudo-Boolean encoding
#[no_mangle]
#[allow(clippy::missing_safety_doc)]
pub unsafe extern "C" fn dpw_new() -> *mut DynamicPolyWatchdog {
    Box::into_raw(Box::default())
}

/// Frees the memory associated with a [`DynamicPolyWatchdog`]
///
/// # Safety
///
/// `dpw` must be a return value of [`dpw_new`] and cannot be used afterwards again.
#[no_mangle]
pub unsafe extern "C" fn dpw_drop(dpw: *mut DynamicPolyWatchdog) {
    drop(Box::from_raw(dpw));
}

/// Reserves all auxiliary variables that the encoding might need
///
/// All calls to [`dpw_encode_ub`] following a call to this function are guaranteed to not increase
/// the value of `n_vars_used`. This does _not_ hold if [`dpw_add`] is called in between
///
/// # Safety
///
/// `dpw` must be a return value of [`dpw_new`] that [`dpw_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn dpw_reserve(dpw: *mut DynamicPolyWatchdog, n_vars_used: &mut u32) {
    let mut var_manager = VarManager::new(n_vars_used);
    (*dpw).reserve(&mut var_manager);
}

/// Adds a new input literal to a [`DynamicPolyWatchdog`] encoding
///
/// # Errors
///
/// - If `lit` is not a valid IPASIR-style literal (e.g., `lit = 0`),
///   [`MaybeError::InvalidLiteral`] is returned
///
/// # Safety
///
/// `dpw` must be a return value of [`dpw_new`] that [`dpw_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn dpw_add(
    dpw: *mut DynamicPolyWatchdog,
    lit: c_int,
    weight: usize,
) -> MaybeError {
    let Ok(lit) = Lit::from_ipasir(lit) else {
        return MaybeError::InvalidLiteral;
    };
    if (*dpw).add_input(lit, weight).is_ok() {
        MaybeError::Ok
    } else {
        MaybeError::InvalidState
    }
}

/// Lazily builds the _change in_ pseudo-Boolean encoding to enable upper bounds in a given range.
/// A change might be added literals or changed bounds.
///
/// The min and max bounds are inclusive. After a call to [`dpw_encode_ub`] with `min_bound=2` and
/// `max_bound=4` bound including `<= 2` and `<= 4` can be enforced.
///
/// Clauses are returned via the `collector`. The `collector` function should expect clauses to be
/// passed similarly to `ipasir_add`, as a 0-terminated sequence of literals where the literals are
/// passed as the first argument and the `collector_data` as a second.
///
/// `n_vars_used` must be the number of variables already used and will be incremented by the
/// number of variables used up in the encoding.
///
/// # Panics
///
/// If `min_bound > max_bound`.
///
/// # Safety
///
/// `dpw` must be a return value of [`dpw_new`] that [`dpw_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn dpw_encode_ub(
    dpw: *mut DynamicPolyWatchdog,
    min_bound: usize,
    max_bound: usize,
    n_vars_used: &mut u32,
    collector: CClauseCollector,
    collector_data: *mut c_void,
) {
    assert!(min_bound <= max_bound);
    let mut collector = ClauseCollector::new(collector, collector_data);
    let mut var_manager = VarManager::new(n_vars_used);
    (*dpw)
        .encode_ub_change(min_bound..=max_bound, &mut collector, &mut var_manager)
        .expect("CClauseCollector cannot report out of memory");
}

/// Returns assumptions/units for enforcing an upper bound (`sum of lits <= ub`). Make sure that
/// [`dpw_encode_ub`] has been called adequately and nothing has been called afterwards, otherwise
/// [`MaybeError::NotEncoded`] will be returned.
///
/// Assumptions are returned via the collector callback. There is _no_ terminating zero, all
/// assumptions are passed when [`dpw_enforce_ub`] returns.
///
/// # Safety
///
/// `dpw` must be a return value of [`dpw_new`] that [`dpw_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn dpw_enforce_ub(
    dpw: *mut DynamicPolyWatchdog,
    ub: usize,
    collector: CAssumpCollector,
    collector_data: *mut c_void,
) -> MaybeError {
    match (*dpw).enforce_ub(ub) {
        Ok(assumps) => {
            assumps
                .into_iter()
                .for_each(|a| collector(a.to_ipasir(), collector_data));
            MaybeError::Ok
        }
        Err(err) => err.into(),
    }
}
