//! # CaDiCaL Proof Tracing Functionality

use std::{
    ffi::{c_int, c_void},
    marker::PhantomData,
    pin::Pin,
};

use rustsat::{
    solvers::{sat, SolverResult},
    types::{Assignment, Clause, Lit, TernaryVal, Var},
    utils::from_raw_parts_maybe_null,
};

use crate::ffi;

/// The ID of a clause internal to CaDiCaL
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct ClauseId(pub i64);

/// A conclusion for an incremental proof
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Conclusion {
    /// The solver found a conflict of the input clauses
    Conflict,
    /// The solver found the input clauses to be unsatisfiable with the assumptions
    Assumptions,
    /// The solver found the input clauses to be unsatisfiable with the temporary constraint
    Constraint,
}

/// Trait that must be implement for a type that can be used to trace a proof generated by CaDiCaL
///
/// This is the equivalent to the proof tracer Cpp-API of CaDiCaL
///
/// Rather than passing [`Clause`] to the tracer, we use [`CaDiCaLClause`], which
/// lazily converts IPASIR literals to [`Lit`] to not perform any work if the clause is not actually
/// used
#[expect(unused_variables)]
pub trait TraceProof: From<Self::Config> + Unpin {
    type Config;

    const ANTECEDENTS: bool;

    /// Notify the tracer that a original clause has been added.
    ///
    /// Includes ID and whether the clause is redundant or irredundant
    fn add_original_clause(
        &mut self,
        id: ClauseId,
        redundant: bool,
        clause: &CaDiCaLClause,
        restored: bool,
    ) {
    }

    /// Notify the observer that a new clause has been derived.
    ///
    /// Includes ID and whether the clause is redundant or irredundant
    /// If antecedents are derived they will be included here.
    fn add_derived_clause(
        &mut self,
        id: ClauseId,
        redundant: bool,
        clause: &CaDiCaLClause,
        antecedents: &[ClauseId],
    ) {
    }

    /// Notify the observer that a clause is deleted.
    ///
    /// Includes ID and redundant/irredundant
    fn delete_clause(&mut self, id: ClauseId, redundant: bool, clause: &CaDiCaLClause) {}

    /// Notify the observer to remember that the clause might be restored later
    fn weaken_minus(&mut self, id: ClauseId, clause: &CaDiCaLClause) {}

    /// Notify the observer that a clause is strengthened
    fn strengthen(&mut self, id: ClauseId) {}

    /// Notify the observer that the solve call ends with status [`SolverResult`]
    /// If the status is UNSAT and an empty clause has been derived, the second
    /// argument will contain its id.
    /// Note that the empty clause is already added through [`TraceProof::add_derived_clause`]
    /// and finalized with [`TraceProof::finalize_clause`]
    fn report_status(&mut self, status: SolverResult, id: ClauseId) {}

    /// Notify the observer that a clause is finalized.
    fn finalize_clause(&mut self, id: ClauseId, clause: &CaDiCaLClause) {}

    /// Notify the observer that the proof begins with a set of reserved ids
    /// for original clauses. Given ID is the first derived clause ID.
    fn begin_proof(&mut self, id: ClauseId) {}

    /// Notify the observer that an assumption has been added
    fn solve_query(&mut self) {}

    /// Notify the observer that an assumption has been added
    fn add_assumption(&mut self, assumption: Lit) {}

    /// Notify the observer that a constraint has been added
    // Arguments: Data, length, constraint_clause
    fn add_constraint(&mut self, constraint: &CaDiCaLClause) {}

    /// Notify the observer that assumptions and constraints are reset
    fn reset_assumptions(&mut self) {}

    /// Notify the observer that this clause could be derived, which
    /// is the negation of a core of failing assumptions/constraints.
    /// If antecedents are derived they will be included here.
    fn add_assumption_clause(
        &mut self,
        id: ClauseId,
        clause: &CaDiCaLClause,
        antecedents: &[ClauseId],
    ) {
    }

    /// Notify the observer that conclude unsat was requested.
    /// will give either the id of the empty clause, the id of a failing
    /// assumption clause or the ids of the failing constrain clauses
    fn conclude_unsat(&mut self, conclusion: Conclusion, failing: &[ClauseId]) {}

    /// Notify the observer that conclude sat was requested.
    /// will give the complete model as a vector.
    fn conclude_sat(&mut self, solution: &CaDiCaLAssignment) {}

    /// Notify the observer that conclude unknown was requested.
    /// will give the current trail as a vector.
    fn conclude_unknown(&mut self, solution: &CaDiCaLAssignment) {}

    /// Notify the observer that two literals are equivalent
    ///
    /// You receive literals, not variables. You can also get notified
    /// multiple times. You can also get notified of BVA variables, aka
    /// variables you did not declare.
    fn notify_equivalence(&mut self, first: Lit, second: Lit) {}
}

pub(crate) trait DynCompatTraceProof {
    fn add_original_clause(
        &mut self,
        id: ClauseId,
        redundant: bool,
        clause: &CaDiCaLClause,
        restored: bool,
    );
    fn add_derived_clause(
        &mut self,
        id: ClauseId,
        redundant: bool,
        clause: &CaDiCaLClause,
        antecedents: &[ClauseId],
    );
    fn delete_clause(&mut self, id: ClauseId, redundant: bool, clause: &CaDiCaLClause);
    fn weaken_minus(&mut self, id: ClauseId, clause: &CaDiCaLClause);
    fn strengthen(&mut self, id: ClauseId);
    fn report_status(&mut self, status: SolverResult, id: ClauseId);
    fn finalize_clause(&mut self, id: ClauseId, clause: &CaDiCaLClause);
    fn begin_proof(&mut self, id: ClauseId);
    fn solve_query(&mut self);
    fn add_assumption(&mut self, assumption: Lit);
    fn add_constraint(&mut self, constraint: &CaDiCaLClause);
    fn reset_assumptions(&mut self);
    fn add_assumption_clause(
        &mut self,
        id: ClauseId,
        clause: &CaDiCaLClause,
        antecedents: &[ClauseId],
    );
    fn conclude_unsat(&mut self, conclusion: Conclusion, failing: &[ClauseId]);
    fn conclude_sat(&mut self, solution: &CaDiCaLAssignment);
    fn conclude_unknown(&mut self, solution: &CaDiCaLAssignment);
    fn notify_equivalence(&mut self, first: Lit, second: Lit);
}

impl<Tracer> DynCompatTraceProof for Tracer
where
    Tracer: TraceProof,
{
    fn add_original_clause(
        &mut self,
        id: ClauseId,
        redundant: bool,
        clause: &CaDiCaLClause,
        restored: bool,
    ) {
        <Tracer as TraceProof>::add_original_clause(self, id, redundant, clause, restored);
    }

    fn add_derived_clause(
        &mut self,
        id: ClauseId,
        redundant: bool,
        clause: &CaDiCaLClause,
        antecedents: &[ClauseId],
    ) {
        <Tracer as TraceProof>::add_derived_clause(self, id, redundant, clause, antecedents);
    }

    fn delete_clause(&mut self, id: ClauseId, redundant: bool, clause: &CaDiCaLClause) {
        <Tracer as TraceProof>::delete_clause(self, id, redundant, clause);
    }

    fn weaken_minus(&mut self, id: ClauseId, clause: &CaDiCaLClause) {
        <Tracer as TraceProof>::weaken_minus(self, id, clause);
    }

    fn strengthen(&mut self, id: ClauseId) {
        <Tracer as TraceProof>::strengthen(self, id);
    }

    fn report_status(&mut self, status: SolverResult, id: ClauseId) {
        <Tracer as TraceProof>::report_status(self, status, id);
    }

    fn finalize_clause(&mut self, id: ClauseId, clause: &CaDiCaLClause) {
        <Tracer as TraceProof>::finalize_clause(self, id, clause);
    }

    fn begin_proof(&mut self, id: ClauseId) {
        <Tracer as TraceProof>::begin_proof(self, id);
    }

    fn solve_query(&mut self) {
        <Tracer as TraceProof>::solve_query(self);
    }

    fn add_assumption(&mut self, assumption: Lit) {
        <Tracer as TraceProof>::add_assumption(self, assumption);
    }

    fn add_constraint(&mut self, constraint: &CaDiCaLClause) {
        <Tracer as TraceProof>::add_constraint(self, constraint);
    }

    fn reset_assumptions(&mut self) {
        <Tracer as TraceProof>::reset_assumptions(self);
    }

    fn add_assumption_clause(
        &mut self,
        id: ClauseId,
        clause: &CaDiCaLClause,
        antecedents: &[ClauseId],
    ) {
        <Tracer as TraceProof>::add_assumption_clause(self, id, clause, antecedents);
    }

    fn conclude_unsat(&mut self, conclusion: Conclusion, failing: &[ClauseId]) {
        <Tracer as TraceProof>::conclude_unsat(self, conclusion, failing);
    }

    fn conclude_sat(&mut self, solution: &CaDiCaLAssignment) {
        <Tracer as TraceProof>::conclude_sat(self, solution);
    }

    fn conclude_unknown(&mut self, solution: &CaDiCaLAssignment) {
        <Tracer as TraceProof>::conclude_unknown(self, solution);
    }

    fn notify_equivalence(&mut self, first: Lit, second: Lit) {
        <Tracer as TraceProof>::notify_equivalence(self, first, second);
    }
}

/// A handle to an attached proof tracer in order to be able to detach it again
///
/// This is intentionally not [`Clone`] or [`Copy`] so that it cannot be used after the tracer has
/// been disconnected from the solver
#[derive(Debug)]
pub struct ProofTracerHandle<PT> {
    c_class: *mut ffi::CCaDiCaLTracer,
    tracer: *mut PT,
    trait_ptr: *mut *mut dyn DynCompatTraceProof,
}

impl<PT> Drop for ProofTracerHandle<PT> {
    fn drop(&mut self) {
        let trait_ptr = unsafe { Box::from_raw(self.trait_ptr) };
        drop(trait_ptr);
        let tracer = unsafe { Box::from_raw(self.tracer) };
        drop(tracer);
    }
}

/// Error stating that a provided proof tracer was not connected to the solver
#[derive(Clone, Copy, Debug, thiserror::Error)]
#[error("the provided proof tracer handle is not connected to the solver")]
pub struct ProofTracerNotConnected;

impl super::CaDiCaL<'_, '_> {
    /// Connects a proof tracer to the solver
    ///
    /// **Note**: in order to not leak memory, dropping the [`ProofTracerHandle`] will drop the
    /// proof tracer. Ensure therefore that the handle is not dropped before the solver is not used
    /// anymore, or call [`Self::disconnect_proof_tracer`], if you do not need the proof tracer
    /// anymore.
    pub fn connect_proof_tracer<PT>(
        &mut self,
        tracer: PT,
        antecedents: bool,
    ) -> ProofTracerHandle<PT>
    where
        PT: TraceProof + 'static,
    {
        let tracer = Box::new(tracer);
        let tracer = Box::into_raw(tracer);
        let trait_ptr = Box::new(tracer as *mut dyn DynCompatTraceProof);
        let trait_ptr = Box::into_raw(trait_ptr);
        let ptr = unsafe {
            ffi::ccadical_connect_proof_tracer(
                self.handle,
                trait_ptr.cast::<c_void>(),
                ffi::prooftracer::DISPATCH_CALLBACKS,
                antecedents,
            )
        };
        ProofTracerHandle {
            c_class: ptr,
            tracer,
            trait_ptr,
        }
    }

    /// Disconnects a proof tracer from the solver
    ///
    /// # Errors
    ///
    /// If the handle is not connected to the given solver, returns [`ProofTracerNotConnected`]
    // We intentionally pass the handle by value here so that it cannot be used afterwards, since
    // it is not Clone of Copy
    pub fn disconnect_proof_tracer<PT>(
        &mut self,
        handle: ProofTracerHandle<PT>,
    ) -> Result<PT, ProofTracerNotConnected>
    where
        PT: TraceProof + 'static,
    {
        if !unsafe { ffi::ccadical_disconnect_proof_tracer(self.handle, handle.c_class) } {
            return Err(ProofTracerNotConnected);
        }
        let trait_ptr = unsafe { Box::from_raw(handle.trait_ptr) };
        drop(trait_ptr);
        let tracer = unsafe { Box::from_raw(handle.tracer) };
        // avoid dropping tracer in drop implementation
        let _ = std::mem::ManuallyDrop::new(handle);
        Ok(*tracer)
    }

    /// Gets a mutable reference to a connected proof tracer
    // We are intentionally taking self, since the solver "owns" the tracer, even though the
    // compiler doesn't know this
    #[expect(clippy::unused_self)]
    // The handle can only have originated from connect_proof_tracer, the pointer can therefore
    // never be null
    #[expect(clippy::missing_panics_doc)]
    pub fn proof_tracer_mut<PT>(&mut self, handle: &ProofTracerHandle<PT>) -> &mut PT
    where
        PT: TraceProof + 'static,
    {
        unsafe { handle.tracer.as_mut() }.expect("unexpected null ptr")
    }
}

/// A clause passed from CaDiCaL
///
/// This performs lazy conversion to [`Lit`] in order to avoid unnecessary memory allocations and
/// work
#[derive(Debug)]
pub struct CaDiCaLClause<'slf> {
    lits: &'slf [c_int],
}

impl CaDiCaLClause<'_> {
    pub(crate) fn new(cl_len: usize, cl_data: *const c_int) -> Self {
        Self {
            lits: unsafe { from_raw_parts_maybe_null(cl_data, cl_len) },
        }
    }

    /// Gets an iterator over the literals in the clause
    ///
    /// # Panics
    ///
    /// If CaDiCaL passes an invalid IPASIR literal
    pub fn iter(&self) -> impl Iterator<Item = Lit> + '_ {
        self.lits
            .iter()
            .map(|&lit| Lit::from_ipasir(lit).expect("got invalid literal from CaDiCaL"))
    }

    /// Gets the length of the clause
    #[inline]
    #[must_use]
    pub fn len(&self) -> usize {
        self.lits.len()
    }

    /// Checks if the clause is empty
    #[inline]
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.lits.is_empty()
    }

    /// Converts the clause into an owned [`Clause`]
    ///
    /// This is costly because of IPASIR to [`Lit`] conversion and memory allocation
    #[must_use]
    pub fn to_owned(&self) -> Clause {
        self.iter().collect()
    }
}

#[cfg(feature = "pigeons")]
impl pigeons::ConstraintLike<rustsat::types::Var> for CaDiCaLClause<'_> {
    fn rhs(&self) -> isize {
        1
    }

    fn sum_iter(&self) -> impl Iterator<Item = (isize, pigeons::Axiom<rustsat::types::Var>)> {
        self.iter().map(|l| (1, pigeons::Axiom::from(l)))
    }
}

/// An assignment passed from CaDiCaL
///
/// This performs lazy conversion to [`Lit`] in order to avoid unnecessary memory allocations and
/// work
#[derive(Debug)]
pub struct CaDiCaLAssignment<'slf> {
    lits: &'slf [c_int],
}

impl CaDiCaLAssignment<'_> {
    pub(crate) fn new(assign_len: usize, assign_data: *const c_int) -> Self {
        Self {
            lits: unsafe { from_raw_parts_maybe_null(assign_data, assign_len) },
        }
    }

    /// Gets an iterator over the literals in the assignment
    ///
    /// # Panics
    ///
    /// If CaDiCaL passes an invalid IPASIR literal
    pub fn iter(&self) -> impl Iterator<Item = Lit> + '_ {
        self.lits
            .iter()
            .map(|&lit| Lit::from_ipasir(lit).expect("got invalid literal from CaDiCaL"))
    }

    /// Gets the length of the clause
    #[inline]
    #[must_use]
    pub fn len(&self) -> usize {
        self.lits.len()
    }

    /// Checks if the clause is empty
    #[inline]
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.lits.is_empty()
    }

    /// Converts the clause into an owned [`rustsat::types::Assignment`]
    ///
    /// This is costly because of IPASIR to [`Lit`] conversion and memory allocation
    #[must_use]
    pub fn to_owned(&self) -> Assignment {
        self.iter().collect()
    }
}

pub trait Traceable: sat::Solve
where
    Self::Init: ConnectProofTracerInternal<Self>,
    Self::Input: ConnectProofTracer<Self> + ConnectProofTracerInternal<Self>,
{
}

impl Traceable for super::CaDiCaLNewApi {}

pub trait ConnectProofTracer<Solver>
where
    Solver: sat::Solve,
    Solver::Input: ConnectProofTracerInternal<Solver>,
{
    fn connect_proof_tracer<Tracer>(self, tracer: Tracer) -> TracedCaDiCaLInput<Solver, Tracer>
    where
        Tracer: TraceProof;
}

impl ConnectProofTracer<super::CaDiCaLNewApi> for super::CaDiCaLState<super::Input> {
    fn connect_proof_tracer<Tracer>(
        mut self,
        tracer: Tracer,
    ) -> TracedCaDiCaLInput<super::CaDiCaLNewApi, Tracer>
    where
        Tracer: TraceProof,
    {
        let tracer = Box::pin(tracer);
        self.connect_proof_tracer_internal(&tracer);
        TracedCaDiCaLInput {
            solver_state: self,
            tracer,
        }
    }
}

trait ConnectProofTracerInternal<Solver>
where
    Solver: sat::Solve,
{
    fn connect_proof_tracer_internal<Tracer>(&mut self, tracer: &Pin<Box<Tracer>>)
    where
        Tracer: DynCompatTraceProof;

    fn disconnect_proof_tracer_internal<Tracer>(&mut self, tracer: &Pin<Box<Tracer>>)
    where
        Tracer: DynCompatTraceProof;
}

impl ConnectProofTracerInternal<super::CaDiCaLNewApi> for super::CaDiCaLState<super::Init> {
    fn connect_proof_tracer_internal<Tracer>(&mut self, tracer: &Pin<Box<Tracer>>)
    where
        Tracer: DynCompatTraceProof,
    {
        todo!()
    }

    fn disconnect_proof_tracer_internal<Tracer>(&mut self, tracer: &Pin<Box<Tracer>>)
    where
        Tracer: DynCompatTraceProof,
    {
        todo!()
    }
}

impl ConnectProofTracerInternal<super::CaDiCaLNewApi> for super::CaDiCaLState<super::Input> {
    fn connect_proof_tracer_internal<Tracer>(&mut self, tracer: &Pin<Box<Tracer>>)
    where
        Tracer: DynCompatTraceProof,
    {
        todo!()
    }

    fn disconnect_proof_tracer_internal<Tracer>(&mut self, tracer: &Pin<Box<Tracer>>)
    where
        Tracer: DynCompatTraceProof,
    {
        todo!()
    }
}

#[derive(Debug)]
pub struct TracedCaDiCaL<Solver, Tracer> {
    solver: PhantomData<Solver>,
    tracer: PhantomData<Tracer>,
}

impl<Solver, Tracer> Traceable for TracedCaDiCaL<Solver, Tracer>
where
    Solver: Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver> + ConnectProofTracerInternal<Solver>,
    Tracer: TraceProof,
{
}

impl<Solver, Tracer> sat::Solve for TracedCaDiCaL<Solver, Tracer>
where
    Solver: sat::Solve + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver> + ConnectProofTracerInternal<Solver>,
    Tracer: TraceProof,
{
    type Init = TracedCaDiCaLInit<Solver, Tracer>;

    type Input = TracedCaDiCaLInput<Solver, Tracer>;

    type Sat = TracedCaDiCaLSat<Solver, Tracer>;

    type Unsat = TracedCaDiCaLUnsat<Solver, Tracer>;

    type Unknown = TracedCaDiCaLUnknown<Solver, Tracer>;

    fn signature() -> &'static str {
        Solver::signature()
    }
}

impl<Solver, Tracer> sat::SolveIncremental for TracedCaDiCaL<Solver, Tracer>
where
    Solver: sat::SolveIncremental + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver>
        + ConnectProofTracerInternal<Solver>
        + sat::SolveAssumptions<Solver>
        + sat::SolveGuarded<Solver>
        + From<Solver::Sat>
        + From<Solver::Unsat>
        + From<Solver::Unknown>,
    Solver::Unsat: sat::UnsatIncremental,
    Tracer: TraceProof,
{
    type SatGuard<'a> = Solver::SatGuard<'a>;
    type UnsatGuard<'a> = Solver::UnsatGuard<'a>;
    type UnknownGuard<'a> = Solver::UnknownGuard<'a>;
}

#[derive(Debug)]
pub struct TracedCaDiCaLInit<Solver, Tracer>
where
    Solver: sat::Solve,
{
    solver_state: Solver::Init,
    tracer: Pin<Box<Tracer>>,
}

impl<Solver, Tracer> sat::Init for TracedCaDiCaLInit<Solver, Tracer>
where
    Solver: sat::Solve,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Tracer: TraceProof,
{
    type Config = (<Solver::Init as sat::Init>::Config, Tracer::Config);

    type Option = <Solver::Init as sat::Init>::Option;

    fn set_option(&mut self, option: Self::Option) -> &mut Self {
        self.solver_state.set_option(option);
        self
    }
}

impl<Solver, Tracer> From<(<Solver::Init as sat::Init>::Config, Tracer::Config)>
    for TracedCaDiCaLInit<Solver, Tracer>
where
    Solver: sat::Solve,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Tracer: TraceProof,
{
    fn from(
        (solver_cfg, tracer_cfg): (<Solver::Init as sat::Init>::Config, Tracer::Config),
    ) -> Self {
        let mut solver_state = Solver::Init::from(solver_cfg);
        let tracer = Box::pin(Tracer::from(tracer_cfg));
        solver_state.connect_proof_tracer_internal(&tracer);
        Self {
            solver_state,
            tracer,
        }
    }
}

impl<Solver, Tracer> ConnectProofTracerInternal<TracedCaDiCaL<Solver, Tracer>>
    for TracedCaDiCaLInit<Solver, Tracer>
where
    Solver: sat::Solve + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver> + ConnectProofTracerInternal<Solver>,
    Tracer: TraceProof,
{
    fn connect_proof_tracer_internal<OtherTracer>(&mut self, tracer: &Pin<Box<OtherTracer>>)
    where
        OtherTracer: DynCompatTraceProof,
    {
        self.solver_state.connect_proof_tracer_internal(tracer);
    }

    fn disconnect_proof_tracer_internal<OtherTracer>(&mut self, tracer: &Pin<Box<OtherTracer>>)
    where
        OtherTracer: DynCompatTraceProof,
    {
        self.solver_state.disconnect_proof_tracer_internal(tracer);
    }
}

#[derive(Debug)]
pub struct TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: sat::Solve,
{
    solver_state: Solver::Input,
    tracer: Pin<Box<Tracer>>,
}

impl<Solver, Tracer> TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: sat::Solve,
    Tracer: TraceProof,
{
    pub fn disconnect_proof_tracer(self) -> (Solver::Input, Tracer) {
        let tracer = *Pin::into_inner(self.tracer);
        (self.solver_state, tracer)
    }
}

impl<Solver, Tracer> sat::Input<TracedCaDiCaL<Solver, Tracer>>
    for TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver> + ConnectProofTracerInternal<Solver>,
    Tracer: TraceProof,
{
    type Option = ();

    fn set_option(&mut self, option: Self::Option) -> &mut Self {
        todo!()
    }

    fn reserve(&mut self, max_var: Var) -> rustsat::MightMemout<&Self> {
        self.solver_state.reserve(max_var)?;
        Ok(self)
    }

    fn add_clause<C>(&mut self, clause: &C) -> rustsat::MightMemout<&Self>
    where
        C: AsRef<rustsat::types::Cl> + ?Sized,
    {
        self.solver_state.add_clause(clause)?;
        Ok(self)
    }

    fn solve(self) -> rustsat::MightMemout<sat::SolveResult<TracedCaDiCaL<Solver, Tracer>>> {
        let result = self.solver_state.solve()?;
        Ok(match result {
            sat::SolveResult::Sat(solver_state) => sat::SolveResult::Sat(TracedCaDiCaLSat {
                solver_state,
                tracer: self.tracer,
            }),
            sat::SolveResult::Unsat(solver_state) => sat::SolveResult::Unsat(TracedCaDiCaLUnsat {
                solver_state,
                tracer: self.tracer,
            }),
            sat::SolveResult::Unknown(solver_state) => {
                sat::SolveResult::Unknown(TracedCaDiCaLUnknown {
                    solver_state,
                    tracer: self.tracer,
                })
            }
        })
    }
}

impl<Solver, Tracer> rustsat::encodings::CollectClauses for TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver> + ConnectProofTracerInternal<Solver>,
{
    fn n_clauses(&self) -> usize {
        self.solver_state.n_clauses()
    }

    fn extend_clauses<T>(&mut self, cl_iter: T) -> Result<(), rustsat::OutOfMemory>
    where
        T: IntoIterator<Item = Clause>,
    {
        self.solver_state.extend_clauses(cl_iter)
    }
}

impl<Solver, Tracer> sat::SolveAssumptions<TracedCaDiCaL<Solver, Tracer>>
    for TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: sat::SolveIncremental + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver>
        + ConnectProofTracerInternal<Solver>
        + sat::SolveAssumptions<Solver>
        + sat::SolveGuarded<Solver>
        + From<Solver::Sat>
        + From<Solver::Unsat>
        + From<Solver::Unknown>,
    Solver::Unsat: sat::UnsatIncremental,
    Tracer: TraceProof,
{
    fn solve_under_assumptions(
        self,
        assumptions: &[Lit],
    ) -> rustsat::MightMemout<sat::SolveResult<TracedCaDiCaL<Solver, Tracer>>> {
        let result = self.solver_state.solve_under_assumptions(assumptions)?;
        Ok(match result {
            sat::SolveResult::Sat(solver_state) => sat::SolveResult::Sat(TracedCaDiCaLSat {
                solver_state,
                tracer: self.tracer,
            }),
            sat::SolveResult::Unsat(solver_state) => sat::SolveResult::Unsat(TracedCaDiCaLUnsat {
                solver_state,
                tracer: self.tracer,
            }),
            sat::SolveResult::Unknown(solver_state) => {
                sat::SolveResult::Unknown(TracedCaDiCaLUnknown {
                    solver_state,
                    tracer: self.tracer,
                })
            }
        })
    }
}

impl<Solver, Tracer> sat::SolveGuarded<TracedCaDiCaL<Solver, Tracer>>
    for TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: sat::SolveIncremental + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver>
        + ConnectProofTracerInternal<Solver>
        + sat::SolveAssumptions<Solver>
        + sat::SolveGuarded<Solver>
        + From<Solver::Sat>
        + From<Solver::Unsat>
        + From<Solver::Unknown>,
    Solver::Unsat: sat::UnsatIncremental,
    Tracer: TraceProof,
{
    fn solve(
        &mut self,
    ) -> rustsat::MightMemout<sat::SolveGuard<'_, TracedCaDiCaL<Solver, Tracer>>> {
        let res = <Solver::Input as sat::SolveGuarded<Solver>>::solve(&mut self.solver_state)?;
        Ok(match res {
            sat::SolveGuard::Sat(guard) => sat::SolveGuard::Sat(guard),
            sat::SolveGuard::Unsat(guard) => sat::SolveGuard::Unsat(guard),
            sat::SolveGuard::Unknown(guard) => sat::SolveGuard::Unknown(guard),
        })
    }

    fn solve_under_assumptions(
        &mut self,
        assumptions: &[Lit],
    ) -> rustsat::MightMemout<sat::SolveGuard<'_, TracedCaDiCaL<Solver, Tracer>>> {
        let res = <Solver::Input as sat::SolveGuarded<Solver>>::solve_under_assumptions(
            &mut self.solver_state,
            assumptions,
        )?;
        Ok(match res {
            sat::SolveGuard::Sat(guard) => sat::SolveGuard::Sat(guard),
            sat::SolveGuard::Unsat(guard) => sat::SolveGuard::Unsat(guard),
            sat::SolveGuard::Unknown(guard) => sat::SolveGuard::Unknown(guard),
        })
    }
}

impl<Solver, Tracer> From<TracedCaDiCaLInit<Solver, Tracer>> for TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: sat::Solve,
{
    fn from(value: TracedCaDiCaLInit<Solver, Tracer>) -> Self {
        Self {
            solver_state: value.solver_state.into(),
            tracer: value.tracer,
        }
    }
}

impl<Solver, Tracer> From<TracedCaDiCaLSat<Solver, Tracer>> for TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: sat::SolveIncremental + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver>
        + ConnectProofTracerInternal<Solver>
        + sat::SolveAssumptions<Solver>
        + sat::SolveGuarded<Solver>
        + From<Solver::Sat>
        + From<Solver::Unsat>
        + From<Solver::Unknown>,
    Solver::Unsat: sat::UnsatIncremental,
{
    fn from(value: TracedCaDiCaLSat<Solver, Tracer>) -> Self {
        Self {
            solver_state: value.solver_state.into(),
            tracer: value.tracer,
        }
    }
}

impl<Solver, Tracer> From<TracedCaDiCaLUnsat<Solver, Tracer>> for TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: sat::SolveIncremental + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver>
        + ConnectProofTracerInternal<Solver>
        + sat::SolveAssumptions<Solver>
        + sat::SolveGuarded<Solver>
        + From<Solver::Sat>
        + From<Solver::Unsat>
        + From<Solver::Unknown>,
    Solver::Unsat: sat::UnsatIncremental,
{
    fn from(value: TracedCaDiCaLUnsat<Solver, Tracer>) -> Self {
        Self {
            solver_state: value.solver_state.into(),
            tracer: value.tracer,
        }
    }
}

impl<Solver, Tracer> From<TracedCaDiCaLUnknown<Solver, Tracer>>
    for TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: sat::SolveIncremental + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver>
        + ConnectProofTracerInternal<Solver>
        + sat::SolveAssumptions<Solver>
        + sat::SolveGuarded<Solver>
        + From<Solver::Sat>
        + From<Solver::Unsat>
        + From<Solver::Unknown>,
    Solver::Unsat: sat::UnsatIncremental,
{
    fn from(value: TracedCaDiCaLUnknown<Solver, Tracer>) -> Self {
        Self {
            solver_state: value.solver_state.into(),
            tracer: value.tracer,
        }
    }
}

impl<Solver, Tracer> ConnectProofTracer<TracedCaDiCaL<Solver, Tracer>>
    for TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: sat::Solve + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver> + ConnectProofTracerInternal<Solver>,
    Tracer: TraceProof,
{
    fn connect_proof_tracer<OtherTracer>(
        mut self,
        tracer: OtherTracer,
    ) -> TracedCaDiCaLInput<TracedCaDiCaL<Solver, Tracer>, OtherTracer>
    where
        OtherTracer: TraceProof,
    {
        let tracer = Box::pin(tracer);
        self.connect_proof_tracer_internal(&tracer);
        TracedCaDiCaLInput {
            solver_state: self,
            tracer,
        }
    }
}

impl<Solver, Tracer> ConnectProofTracerInternal<TracedCaDiCaL<Solver, Tracer>>
    for TracedCaDiCaLInput<Solver, Tracer>
where
    Solver: sat::Solve + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver> + ConnectProofTracerInternal<Solver>,
    Tracer: TraceProof,
{
    fn connect_proof_tracer_internal<OtherTracer>(&mut self, tracer: &Pin<Box<OtherTracer>>)
    where
        OtherTracer: DynCompatTraceProof,
    {
        self.solver_state.connect_proof_tracer_internal(tracer);
    }

    fn disconnect_proof_tracer_internal<OtherTracer>(&mut self, tracer: &Pin<Box<OtherTracer>>)
    where
        OtherTracer: DynCompatTraceProof,
    {
        self.solver_state.disconnect_proof_tracer_internal(tracer);
    }
}

#[derive(Debug)]
pub struct TracedCaDiCaLSat<Solver, Tracer>
where
    Solver: sat::Solve,
{
    solver_state: Solver::Sat,
    tracer: Pin<Box<Tracer>>,
}

impl<Solver, Tracer> sat::Sat for TracedCaDiCaLSat<Solver, Tracer>
where
    Solver: Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver> + ConnectProofTracerInternal<Solver>,
{
    fn variable_value(&self, var: Var) -> TernaryVal {
        self.solver_state.variable_value(var)
    }
}

#[derive(Debug)]
pub struct TracedCaDiCaLUnsat<Solver, Tracer>
where
    Solver: sat::Solve,
{
    solver_state: Solver::Unsat,
    tracer: Pin<Box<Tracer>>,
}

impl<Solver, Tracer> sat::UnsatIncremental for TracedCaDiCaLUnsat<Solver, Tracer>
where
    Solver: sat::SolveIncremental + Traceable,
    Solver::Init: ConnectProofTracerInternal<Solver>,
    Solver::Input: ConnectProofTracer<Solver>
        + ConnectProofTracerInternal<Solver>
        + sat::SolveAssumptions<Solver>
        + sat::SolveGuarded<Solver>
        + From<Solver::Sat>
        + From<Solver::Unsat>
        + From<Solver::Unknown>,
    Solver::Unsat: sat::UnsatIncremental,
{
    fn core(&mut self) -> &[Lit] {
        self.solver_state.core()
    }

    fn failed(&mut self, assumption: Lit) -> bool {
        self.solver_state.failed(assumption)
    }
}

#[derive(Debug)]
pub struct TracedCaDiCaLUnknown<Solver, Tracer>
where
    Solver: sat::Solve,
{
    solver_state: Solver::Unknown,
    tracer: Pin<Box<Tracer>>,
}

#[cfg(test)]
mod test {
    use crate::CaDiCaL;

    struct Tracer;

    impl super::TraceProof for Tracer {
        type Config = ();
    }

    impl From<()> for Tracer {
        fn from(_: ()) -> Self {
            Tracer
        }
    }

    #[test]
    fn connect_tracer() {
        let mut slv = CaDiCaL::default();
        let handle = slv.connect_proof_tracer(Tracer, false);
        let _ = slv.disconnect_proof_tracer(handle).unwrap();
    }
}
